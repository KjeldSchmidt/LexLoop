#!/usr/bin/env bash
API_BASE_DEV="https://d1su4015b7ijdn.cloudfront.net/api/"

## run: Run the server
function task_run {
  task_db_up
  uv run python -m uvicorn lexloop.main:app
}

## db-up: Start the database container
function task_db_up {
  docker compose -f local-postgres.yml up -d --wait postgres
}

## db-down: Start the database container
function task_db_down {
    docker compose -f local-postgres.yml down
}

## fmt: Formats all files
function task_fmt {
  uv run ruff format
}

## fmt-check: Exits with non-zero code if any files would be formatted
function task_fmt_check {
  uv run ruff format --check
}

## tests: Run unit tests
function task_test {
  export $(cat .env | xargs)
  export DB_URL=$LOCAL_TEST_DB_URL
  docker compose -f local-test-postgres.yml up -d --wait postgres
  uv run pytest lexloop
  docker compose -f local-test-postgres.yml down
}

## smoke-test: Run smoke tests against deployed API
function task_smoke_test {
  uv run --with httpx --with pytest pytest smoke_tests -v
}

## lint: Runs static linting, including fixes for local development
function task_lint {
  uv run ruff check --fix
}

## lint-check: Runs static linting without automatic fixes for CI
function task_lint_check {
  uv run ruff check
}

## types: Statically verify types
function task_types {
  uv run mypy .
}

## quality-gates: Run quality checks for deployment confidence
function task_quality_gates {
  task_fmt
  task_lint
  task_types
  task_test
}

## build: creates a .zip-bundle ready for deployment as lambda
function task_build {
  build_dir_name="lex-api-bundle"
  rm -rf $build_dir_name
  mkdir -p $build_dir_name
  uv sync --no-dev
  python_version=$(cat .python-version)
  site_packages_path=".venv/lib/python${python_version}/site-packages"
  cp -r "$site_packages_path"/* $build_dir_name
  cp -r lexloop "$build_dir_name/lexloop"
  (cd $build_dir_name && zip -r "../${build_dir_name}.zip" .)
  rm -rf $build_dir_name
}

## db-migration-new: Create a new database migration with auto-generated changes (usage: ./do db-migration-new <title>)
function task_db_migration_new {
  local title="$1"
  if [ -z "$title" ]; then
    echo "Error: title is not set. Usage: ./do db-migration-new <description_of_changes>"
    exit 1
  fi
  
  path=$(uv run alembic revision --autogenerate -m "$title" | grep -oE "[^ ]+versions/[^ ]+\.py")
  dir=$(dirname "$path")
  file=$(basename "$path")
  highest=$(ls "$dir" | grep -v "$file" | grep -oE "^0[0-9]{3}" | sort -n | tail -n 1)
  next=$(printf "%04d" $(( ${highest#0} + 1 )))
  newfile="${next}_${file}"
  mv "$path" "$dir/$newfile"
  echo "Created migration: $dir/$newfile"
}

## db-migrate-up
function task_db_migrate_up {
  task_db_up
  uv run alembic upgrade head
}

## db-migrate-remote: Apply migrations to remote database (usage: ./do db-migrate-remote <dev|prod>)
function task_db_migrate_remote {
  local env="${1:-}"
  if [ -z "$env" ]; then
    echo "Error: environment not specified. Usage: ./do db-migrate-remote <dev|prod>"
    exit 1
  fi
  
  echo "Fetching DB connection string for $env environment..."
  pushd "../infrastructure/env/$env" >/dev/null
  terraform init -reconfigure >/dev/null
  export DB_URL=$(terraform output -raw db_url)
  popd >/dev/null
  
  echo "Running migrations against $env database..."
  uv run alembic upgrade head
  echo "Migrations applied successfully âœ…"
}

function task_setup {
  if ! command -v uv >/dev/null 2>&1; then
    curl -LsSf https://astral.sh/uv/install.sh | sh
  fi
}

#-------- All task definitions go above this line --------#

# Bash Strict Mode - For details, see
# https://gist.github.com/mohanpedala/1e2ff5661761d3abd0385e8223e16425
set -u     # Raise error when using undefined variables
set -e     # Raise error if any command has a non-zero exit status
# set -x   # Enable this optionally to print every command executed by bash
set -o pipefail  # Prevent pipelines from masking errors

function task_usage {
    echo "Usage: $0"
    sed -n 's/^##//p' <"$0" | column -t -s ':' |  sed -E $'s/^/\t/'
}

cmd=${1:-}
shift || true
resolved_command=$(echo "task_${cmd}" | sed 's/-/_/g')
if [[ "$(LC_ALL=C type -t "${resolved_command}")" == "function" ]]; then
    pushd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null
    ${resolved_command} "$@"
else
    task_usage
    if [ -n "${cmd}" ]; then
      echo "'$cmd' could not be resolved - please use one of the above tasks"
      exit 1
    fi
fi
